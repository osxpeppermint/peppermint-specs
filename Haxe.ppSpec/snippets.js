ace.define("ace/snippets/haxe",["require","exports","module"],function(e,t,n){"use strict";t.snippetText='# hxml --altfmt\nsnippet alt\n	--altfmt\n# hxml --auto-xml\nsnippet ax\n	--auto-xml\n# hxml --display\nsnippet dis\n	--display\n# hxml --flash-strict\nsnippet fs\n	--flash-strict\n# hxml --flash-use-stage\nsnippet fus\n	--flash-use-stage\n# hxml --gen-hx-classes\nsnippet ghc\n	--gen-hx-classes ${1:file}\n# hxml --help\nsnippet h\n	--help\n# hxml --neko-source\nsnippet ns\n	--neko-source\n# hxml --next\nsnippet n\n	--next\n# hxml --no-inline\nsnippet no\n	--no-inline\n# hxml --no-output\nsnippet no\n	--no-output\n# hxml --no-traces\nsnippet nt\n	--no-traces\n# hxml --times\nsnippet t\n	--times\n# hxml -D\nsnippet d\n	-D ${1:var}\n# hxml -as3\nsnippet as3\n	-as3 ${1:directory}\n# hxml -cmd\nsnippet cm\n	-cmd ${1:command}\n# hxml -cp\nsnippet cp\n	-cp ${1:path}\n# hxml -debug\nsnippet deb\n	-debug\n# hxml -exclude\nsnippet ex\n	-exclude ${1:file}\n# hxml -help\nsnippet h\n	-help\n# hxml -js\nsnippet js\n	-js ${1:file}.js\n# hxml -lib\nsnippet lib\n	-lib ${1:lib_name}\n# hxml -main\nsnippet main\n	-main ${1:main_class}\n# hxml -neko\nsnippet neko\n	-neko ${1:file}.n\n# hxml -prompt\nsnippet pr\n	-prompt\n# hxml -resource\nsnippet res\n	-resource ${1:file}@${2:name}\n# hxml -swf-header\nsnippet swf\n	-swf-header ${1:width}:${2:height}:${3:fps}:${4:color}\n# hxml -swf-lib\nsnippet swf\n	-swf-lib ${1:file}\n# hxml -swf-version\nsnippet swf\n	-swf-version ${1:version}\n# hxml -swf\nsnippet swf\n	-swf ${1:file}.swf\n# hxml -v\nsnippet v\n	-v\n# hxml -x\nsnippet x\n	-x ${1:file}.n\n# hxml -xml\nsnippet xml\n	-xml ${1:file}\n# HaXe library copyright\nsnippet (c)\n	/*\n	 * Copyright (c) 2010, The haXe Project Contributors\n	 * All rights reserved.\n	 * Redistribution and use in source and binary forms, with or without\n	 * modification, are permitted provided that the following conditions are met:\n	 *\n	 *   - Redistributions of source code must retain the above copyright\n	 *     notice, this list of conditions and the following disclaimer.\n	 *   - Redistributions in binary form must reproduce the above copyright\n	 *     notice, this list of conditions and the following disclaimer in the\n	 *     documentation and/or other materials provided with the distribution.\n	 *\n	 * THIS SOFTWARE IS PROVIDED BY THE HAXE PROJECT CONTRIBUTORS "AS IS" AND ANY\n	 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n	 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n	 * DISCLAIMED. IN NO EVENT SHALL THE HAXE PROJECT CONTRIBUTORS BE LIABLE FOR\n	 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n	 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n	 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n	 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n	 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n	 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n	 * DAMAGE.\n	 */\n	\n# main class\nsnippet class\n	class ${1:Class}\n	{\n	\n		public function new()\n		{\n			$0\n		}\n	\n		public static function main()\n		{\n			new ${2:Class}();\n		}\n	}\n# trace\nsnippet tr\n	trace($1);$0\n# trace with description\nsnippet trace\n	trace(\'"$1" => ${Std.string($2)}\');$0\n# #if\nsnippet #\n	#if \n# #else\nsnippet #e\n	#else \n# #else error\nsnippet #error\n	#else error\n	\n# try\nsnippet try\n	try{\n		$0\n	}catch ( ${1:error:Dynamic} ){\n		trace(\'Error: $error\');\n	}\n# catch\nsnippet catch\n	catch ( ${1:error } ) {\n		${2:expression}\}\n# do..while\nsnippet do\n	do {\n		$0\n	} while ( ${1:condition} );\n# continue\nsnippet co\n	continue;\n# break\nsnippet br\n	break;\n# if\nsnippet if\n	if ( ${1:condition} ) {\n		$0\n	}\n# else\nsnippet else\n	else {\n		$0\n	}\n# else..if\nsnippet elseif\n	else if ( ${1:condition} ) {\n		$0\n	}\n# if..else\nsnippet ifelse\n	if ( ${1:condition} ) {\n		${2:expression}\n	} else {\n		${3:expression}\n	}\n# switch\nsnippet switch\n	switch ( $1 ) {\n		case $2:\n			$0\n	}\n	\n# case\nsnippet case\n	case ${1:expression}:\n		${2:statement}\n	\n# default\nsnippet def\n	default :\n		${1:statement}\n# return\nsnippet ret\n	return $1;$0\n# block comment\nsnippet /**\n	/**\n	 *  $0\n	 **/\n# package\nsnippet pack\n	package $1;$0\n# class\nsnippet cl\n	class ${1:Class} ${2:extends ${3:SuperClass}} ${4:implements ${5:Interface}} \n	{\n	\n		public function new()\n		{\n			${6:super();\n			}$0\n		}\n	}\n# enum\nsnippet en\n	enum ${1:Name}\n	{\n		$0\n	}\n# extern\nsnippet ex\n	extern \n# import\nsnippet im\n	import ${1:package};$0\n# interface\nsnippet in\n	interface ${1:Interface} ${2:extends ${3:Parent} }\n	{\n		$0\n	}\n# macro class\nsnippet macro\n	@:macro class ${1:Class}\n	{\n		public static function ${2:main}(){\n			$0\n		}\n	}\n# macro function\nsnippet mac\n	@:macro public static function ${1:name}(${2:e:haxe.macro.Expr}) : haxe.macro.Expr\n	{\n		$0\n	}\n# for var in 0...end\nsnippet fori\n	for ( ${1:var} in ${2:0}...${3:end} ) {\n		${4:expression}\n	}\n# for in\nsnippet for\n	for ( $1 in $2 ) {\n		$0\n	}\n# main\nsnippet main\n	public static function main() : Void \n	{\n		$0\n	}\n# function\nsnippet fn\n	function ${1:name} ( ${2:params} )${3: : ${4:Void}}\n	{\n		$0\n	}\n# method\nsnippet fun\n	${1:private }${2:public }${3:static }${4:inline }function ${5:name} ($6)${7: : ${8:Void}}\n	{\n		$0\n	}\n# private\nsnippet pr\n	private \n# public\nsnippet p\n	public \n# inline\nsnippet i\n	inline \n# static\nsnippet s\n	static \n# private function\nsnippet prf\n	private function ${1:name}($2)${3: : ${4:Void}}\n	{\n		$0\n	}\n	\n# private inline function\nsnippet prif\n	private inline function ${1:name}($2)${3: : ${4:Void}}\n	{\n		$0\n	}\n	\n# private static function\nsnippet prsf\n	private static function ${1:name}($2)${3: : ${4:Void}}\n	{\n		$0\n	}\n	\n# private static inline function\nsnippet prsif\n	private static inline function ${1:name}($2)${3: : ${4:Void}}\n	{\n		$0\n	}\n	\n# public function\nsnippet pf\n	public function ${1:name}($2)${3: : ${4:Void}}\n	{\n		$0\n	}\n	\n# public inline function\nsnippet pif\n	public inline function ${1:name}($2)${3: : ${4:Void}}\n	{\n		$0\n	}\n	\n# public static function\nsnippet psf\n	public static function ${1:name}($2)${3: : ${4:Void}}\n	{\n		$0\n	}\n	\n# public static inline function\nsnippet psif\n	public static inline function ${1:name}($2)${3: : ${4:Void}}\n	{\n		$0\n	}\n	\n# autotyped variable\nsnippet v\n	var ${1:name} ${2:: ${3:Type}}${4: = }$5;$0\n# typed variable\nsnippet var\n	var $1:${2:Type} ${3:= }$4;$0\n# private variable\nsnippet prv\n	private var $1 ${2:: ${3:Type}};$0\n# private static variable\nsnippet prsv\n	private static var $1 ${2:: ${3:Type}};$0\n# private static inline variable\nsnippet prsiv\n	private static inline var $1 ${2:: ${3:Type}} = $4;$0\n# public variable\nsnippet pv\n	public var $1 ${2:: ${3:Type}};$0\n# public static variable\nsnippet psv\n	public static var $1 ${2:: ${3:Type}};$0\n# public static inline variable\nsnippet psiv\n	public static inline var $1 ${2:: ${3:Type}} = $4;$0\n',t.scope="haxe"});